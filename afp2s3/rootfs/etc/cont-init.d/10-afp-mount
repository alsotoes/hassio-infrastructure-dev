#!/usr/bin/with-contenv bashio
set -euo pipefail

# Read options via bashio
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:${PATH:-}"
if ! bashio::config.has_value 'afp_server'; then
  bashio::log.fatal "Missing required option: afp_server"
  exit 1
fi
if ! bashio::config.has_value 'afp_user'; then
  bashio::log.fatal "Missing required option: afp_user"
  exit 1
fi
if ! bashio::config.has_value 'afp_password'; then
  bashio::log.fatal "Missing required option: afp_password"
  exit 1
fi

AFP_SERVER=$(bashio::config 'afp_server')
AFP_USER=$(bashio::config 'afp_user')
AFP_PASSWORD=$(bashio::config 'afp_password')

# Optional share and marker
AFP_SHARE=""
if bashio::config.has_value 'afp_share'; then
  AFP_SHARE=$(bashio::config 'afp_share')
fi

AFP_MARKER=""
if bashio::config.has_value 'afp_marker'; then
  AFP_MARKER=$(bashio::config 'afp_marker')
else
  AFP_MARKER=".com.apple.timemachine.supported"
fi

MOUNT_POINT="/mnt/afp"
mkdir -p "${MOUNT_POINT}"

# Ensure /dev/fuse device is present and accessible
if [ ! -e /dev/fuse ]; then
  bashio::log.fatal "Missing /dev/fuse device. Expose it in add-on config (devices: - /dev/fuse)."
  exit 1
fi

# Report current /dev/fuse ownership and permissions
DEV_PERM=$(stat -c "%a" /dev/fuse 2>/dev/null || true)
DEV_UID=$(stat -c "%u" /dev/fuse 2>/dev/null || true)
DEV_GID=$(stat -c "%g" /dev/fuse 2>/dev/null || true)
bashio::log.info "Detected /dev/fuse mode=${DEV_PERM:-unknown} uid=${DEV_UID:-unknown} gid=${DEV_GID:-unknown}"

# If a 'fuse' group exists, try to set group on the device (best-effort)
if grep -qE '^fuse:' /etc/group 2>/dev/null; then
  if ! chgrp fuse /dev/fuse 2>/dev/null; then
    bashio::log.debug "Could not chgrp fuse /dev/fuse (continuing)"
  fi
fi

# Relax permissions to allow FUSE mounts, warn if not 0666
if [ "${DEV_PERM}" != "666" ]; then
  bashio::log.warning "Adjusting /dev/fuse permissions to 0666 (was ${DEV_PERM})."
  if ! chmod 666 /dev/fuse 2>/dev/null; then
    bashio::log.warning "Failed to change /dev/fuse permissions. Mounts may fail."
  fi
  DEV_PERM=$(stat -c "%a" /dev/fuse 2>/dev/null || true)
  bashio::log.info "Post-adjust /dev/fuse mode=${DEV_PERM:-unknown}"
fi

mount_afp_share() {
  local server="$1"
  local mount_point="$2"
  local user="$3"
  local password="$4"

  local server_without_scheme="${server#afp://}"
  local server_path
  if [ "${server_without_scheme}" = "${server}" ]; then
    server_path="${server}"
  else
    server_path="${server_without_scheme}"
  fi
  local url_with_credentials="afp://${user}:${password}@${server_path}"

  # Strongly prefer mount_afp to avoid strict fuse checks in afp_client
  if command -v mount_afp >/dev/null 2>&1; then
    bashio::log.info "Mounting AFP share using mount_afp"
    if mount_afp "${url_with_credentials}" "${mount_point}"; then
      return 0
    fi
    bashio::log.warning "mount_afp failed (see previous errors)."
  else
    bashio::log.error "mount_afp not found in PATH; cannot mount AFP."
  fi

  # Last-resort fallback: try afp_client only if explicitly requested
  # Set ALLOW_AFP_CLIENT_FALLBACK=true in the environment to enable
  if [ "${ALLOW_AFP_CLIENT_FALLBACK:-false}" = "true" ] && command -v afp_client >/dev/null 2>&1; then
    bashio::log.warning "Falling back to afp_client. Beware: it enforces strict /dev/fuse checks."
    if afp_client mount -u "${user}" -p "${password}" "${server}" "${mount_point}"; then
      return 0
    fi
    bashio::log.warning "afp_client mount failed"
  fi

  bashio::log.error "AFP mount failed. Ensure /dev/fuse is exposed with mode 0666 and that Protection mode is disabled."
  return 1
}

# Build final server path, optionally appending share
SERVER_BASE="${AFP_SERVER#afp://}"

# Detect if AFP_SERVER already contains a share/path
SERVER_HAS_PATH=false
if [[ "${SERVER_BASE}" == */* ]]; then
  SERVER_HAS_PATH=true
fi

# If both server has path and afp_share is set, warn and ignore afp_share
if $SERVER_HAS_PATH && [ -n "${AFP_SHARE}" ]; then
  bashio::log.warning "Both 'afp_server' includes a share/path and 'afp_share' is set. Ignoring 'afp_share' to avoid double-appending."
  AFP_SHARE=""
fi

if [ -n "${AFP_SHARE}" ]; then
  SERVER_PATH="${SERVER_BASE%/}/${AFP_SHARE}"
else
  SERVER_PATH="${SERVER_BASE}"
fi
AFP_URL="afp://${SERVER_PATH}"

if ! mount_afp_share "${AFP_URL}" "${MOUNT_POINT}" "${AFP_USER}" "${AFP_PASSWORD}"; then
  bashio::log.fatal "Failed to mount AFP share"
  exit 1
fi

if ! mountpoint -q "${MOUNT_POINT}"; then
  bashio::log.fatal "AFP mount validation failed"
  exit 1
fi

# Enforce marker if configured (non-empty)
if [ -n "${AFP_MARKER}" ]; then
  if [ ! -f "${MOUNT_POINT}/${AFP_MARKER}" ]; then
    bashio::log.fatal "AFP mount validation failed: marker '${AFP_MARKER}' not found"
    exit 1
  fi
fi

# Ensure MinIO binary exists (download if missing)
if [ ! -x /usr/local/bin/minio ]; then
  ARCH=$(uname -m)
  case "${ARCH}" in
    x86_64) MINIO_ARCH="amd64" ;;
    armv7l) MINIO_ARCH="arm" ;;
    aarch64) MINIO_ARCH="arm64" ;;
    *) bashio::log.fatal "Unsupported architecture: ${ARCH}"; exit 1 ;;
  esac
  MINIO_URL="https://dl.min.io/server/minio/release/linux-${MINIO_ARCH}/minio"
  bashio::log.info "Downloading MinIO for ${MINIO_ARCH}"
  wget -q "${MINIO_URL}" -O /usr/local/bin/minio
  chmod +x /usr/local/bin/minio
fi

bashio::log.info "Initialization complete: AFP mounted and MinIO prepared"
