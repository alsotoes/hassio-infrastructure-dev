#!/usr/bin/with-contenv bashio
set -euo pipefail

# Trap unexpected errors to pinpoint failure location (no command echo to avoid secrets)
trap 'bashio::log.error "Unhandled error at ${BASH_SOURCE[0]}:${LINENO}"' ERR

# Helpers
mask_url() {
  local url="$1"
  if [[ "$url" =~ ^afp://([^@]+)@(.+)$ ]]; then
    local creds="${BASH_REMATCH[1]}"
    local tail="${BASH_REMATCH[2]}"
    if [[ "$creds" == *:* ]]; then
      local user="${creds%%:*}"
      echo "afp://${user}:****@${tail}"
    else
      echo "afp://****@${tail}"
    fi
  else
    echo "$url"
  fi
}

log_cmd_path() {
  local bin="$1"
  if command -v "$bin" >/dev/null 2>&1; then
    local p
    p=$(command -v "$bin")
    bashio::log.info "Found $bin at: $p"
    ls -l "$p" 2>/dev/null || true
  else
    bashio::log.info "$bin not found in PATH"
  fi
}

# Read options via bashio
export PATH="/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:${PATH:-}"
if ! bashio::config.has_value 'afp_server'; then
  bashio::log.fatal "Missing required option: afp_server"
  exit 1
fi
if ! bashio::config.has_value 'afp_user'; then
  bashio::log.fatal "Missing required option: afp_user"
  exit 1
fi
if ! bashio::config.has_value 'afp_password'; then
  bashio::log.fatal "Missing required option: afp_password"
  exit 1
fi

AFP_SERVER=$(bashio::config 'afp_server')
AFP_USER=$(bashio::config 'afp_user')
AFP_PASSWORD=$(bashio::config 'afp_password')

bashio::log.info "Runtime: id=$(id -u) gid=$(id -g) groups=$(id -Gn)"
bashio::log.info "Runtime: PATH=${PATH}"

# Optional share and marker
AFP_SHARE=""
if bashio::config.has_value 'afp_share'; then
  AFP_SHARE=$(bashio::config 'afp_share')
fi

AFP_MARKER=""
if bashio::config.has_value 'afp_marker'; then
  AFP_MARKER=$(bashio::config 'afp_marker')
else
  AFP_MARKER=".com.apple.timemachine.supported"
fi

MOUNT_POINT="/mnt/afp"
mkdir -p "${MOUNT_POINT}"

# Ensure /dev/fuse device is present and accessible
if [ ! -e /dev/fuse ]; then
  bashio::log.fatal "Missing /dev/fuse device. Expose it in add-on config (devices: - /dev/fuse)."
  exit 1
fi

# Report current /dev/fuse ownership and permissions
DEV_PERM=$(stat -c "%a" /dev/fuse 2>/dev/null || true)
DEV_UID=$(stat -c "%u" /dev/fuse 2>/dev/null || true)
DEV_GID=$(stat -c "%g" /dev/fuse 2>/dev/null || true)
bashio::log.info "Detected /dev/fuse mode=${DEV_PERM:-unknown} uid=${DEV_UID:-unknown} gid=${DEV_GID:-unknown}"
ls -l /dev/fuse 2>/dev/null || true

# If a 'fuse' group exists, try to set group on the device (best-effort)
if grep -qE '^fuse:' /etc/group 2>/dev/null; then
  if ! chgrp fuse /dev/fuse 2>/dev/null; then
    bashio::log.debug "Could not chgrp fuse /dev/fuse (continuing)"
  fi
fi

# Relax permissions to allow FUSE mounts, warn if not 0666
if [ "${DEV_PERM}" != "666" ]; then
  bashio::log.warning "Adjusting /dev/fuse permissions to 0666 (was ${DEV_PERM})."
  if ! chmod 666 /dev/fuse 2>/dev/null; then
    bashio::log.warning "Failed to change /dev/fuse permissions. Mounts may fail."
  fi
  DEV_PERM=$(stat -c "%a" /dev/fuse 2>/dev/null || true)
  bashio::log.info "Post-adjust /dev/fuse mode=${DEV_PERM:-unknown}"
fi

mount_afp_share() {
  local server="$1"
  local mount_point="$2"
  local user="$3"
  local password="$4"

  local server_without_scheme="${server#afp://}"
  local server_path
  if [ "${server_without_scheme}" = "${server}" ]; then
    server_path="${server}"
  else
    server_path="${server_without_scheme}"
  fi
  local url_with_credentials="afp://${user}:${password}@${server_path}"

  # Strongly prefer mount_afp to avoid strict fuse checks in afp_client
  log_cmd_path mount_afp
  bashio::log.info "Mounting AFP share using mount_afp"
  local masked
  masked=$(mask_url "${url_with_credentials}")
  bashio::log.info "mount_afp URL: ${masked} -> ${mount_point}"
  if output=$(mount_afp "${url_with_credentials}" "${mount_point}" 2>&1); then
    bashio::log.info "mount_afp succeeded"
    return 0
  else
    local code=$?
    bashio::log.error "mount_afp failed (exit=${code}): ${output}"
    bashio::log.info "Fuse device after failure:"; ls -l /dev/fuse || true
  fi

  # Last-resort fallback: try afp_client only if explicitly requested
  # Set ALLOW_AFP_CLIENT_FALLBACK=true in the environment to enable
  if [ "${ALLOW_AFP_CLIENT_FALLBACK:-false}" = "true" ]; then
    log_cmd_path afp_client
    if command -v afp_client >/dev/null 2>&1; then
      bashio::log.warning "Falling back to afp_client. Beware: it enforces strict /dev/fuse checks."
      if output=$(afp_client mount -u "${user}" -p "${password}" "${server}" "${mount_point}" 2>&1); then
        bashio::log.info "afp_client succeeded"
        return 0
      else
        local code=$?
        bashio::log.error "afp_client failed (exit=${code}): ${output}"
      fi
    fi
  fi

  bashio::log.error "AFP mount failed. Ensure /dev/fuse is exposed with mode 0666 and that Protection mode is disabled."
  return 1
}

# Build final server path, optionally appending share
SERVER_BASE="${AFP_SERVER#afp://}"

# Detect if AFP_SERVER already contains a share/path
SERVER_HAS_PATH=false
if [[ "${SERVER_BASE}" == */* ]]; then
  SERVER_HAS_PATH=true
fi

# If both server has path and afp_share is set, warn and ignore afp_share
if $SERVER_HAS_PATH && [ -n "${AFP_SHARE}" ]; then
  bashio::log.warning "Both 'afp_server' includes a share/path and 'afp_share' is set. Ignoring 'afp_share' to avoid double-appending."
  AFP_SHARE=""
fi

if [ -n "${AFP_SHARE}" ]; then
  SERVER_PATH="${SERVER_BASE%/}/${AFP_SHARE}"
else
  SERVER_PATH="${SERVER_BASE}"
fi
AFP_URL="afp://${SERVER_PATH}"
bashio::log.info "Composed AFP URL: $(mask_url "afp://${AFP_USER}:****@${SERVER_PATH}")"

if ! mount_afp_share "${AFP_URL}" "${MOUNT_POINT}" "${AFP_USER}" "${AFP_PASSWORD}"; then
  bashio::log.fatal "Failed to mount AFP share"
  exit 1
fi

if ! mountpoint -q "${MOUNT_POINT}"; then
  bashio::log.fatal "AFP mount validation failed"
  exit 1
fi
bashio::log.info "Mount details:"
mount | grep -E "${MOUNT_POINT}($| )" || true
df -h "${MOUNT_POINT}" || true

# Enforce marker if configured (non-empty)
if [ -n "${AFP_MARKER}" ]; then
  if [ ! -f "${MOUNT_POINT}/${AFP_MARKER}" ]; then
    bashio::log.error "AFP mount validation failed: marker '${AFP_MARKER}' not found"
    bashio::log.info "Listing of mount root to aid debugging:"
    ls -la "${MOUNT_POINT}" || true
    exit 1
  fi
fi

# Ensure MinIO binary exists (download if missing)
if [ ! -x /usr/local/bin/minio ]; then
  ARCH=$(uname -m)
  case "${ARCH}" in
    x86_64) MINIO_ARCH="amd64" ;;
    armv7l) MINIO_ARCH="arm" ;;
    aarch64) MINIO_ARCH="arm64" ;;
    *) bashio::log.fatal "Unsupported architecture: ${ARCH}"; exit 1 ;;
  esac
  MINIO_URL="https://dl.min.io/server/minio/release/linux-${MINIO_ARCH}/minio"
  bashio::log.info "Downloading MinIO for ${MINIO_ARCH}"
  wget -q "${MINIO_URL}" -O /usr/local/bin/minio
  chmod +x /usr/local/bin/minio
fi
log_cmd_path minio

bashio::log.info "Initialization complete: AFP mounted and MinIO prepared"
